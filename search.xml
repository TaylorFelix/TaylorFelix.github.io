<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[离职啦]]></title>
    <url>%2F2018%2F05%2F01%2FNew%2F</url>
    <content type="text"><![CDATA[在四五交际选择离职 说起来可能不够理智，或者是说是积蓄已久的感情在这个时间点一并迸发了。离职时谈及离职原因，我没有多加细说，但也不是毫无缘由，总之是不违背自己初心的决定。所以我此刻记录下来，我，为何离职。 个人能力得不到提升 自己所做所为得不到赏识 过于散漫的生活会加速我的怠惰 这两年我真不在乎工资 后续打算离职虽然是简单快捷的离职，但还是要为自己做一份打算，并且现在是个看技术生存的年代。 1. 尽快找到下一家公司 坚持前端 努力提升和改进自己 多读几本书 解决自己目前的刚需 2. 换角度思考问题过于散漫会松懈自己，逻辑思维还有待提高 努力变好自己吧，加油Felix]]></content>
      <categories>
        <category>New</category>
      </categories>
      <tags>
        <tag>New</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[诸事不顺]]></title>
    <url>%2F2018%2F04%2F05%2FWhisper-4%2F</url>
    <content type="text"><![CDATA[只有不断接触新事物才能不断认识到自己的不足 关于最近其实很烦，去杭州面试了一次，前端。可惜吧，虽然公司不大，氛围也还行，但自己真的是没有那个基础，我已经在努力写前端了，可惜是能力不足。连续三个问题答不出来，我其实是很尴尬的，我都难以回忆当时是怎么走出办公楼的。还有上海，企业是真的大，环境是真的好，要求是真的高。我感觉自己不足的地方很多，那段时间，感觉自己真的是啥都不行。 关于答辩很生气吧，也很后悔，干嘛要进小组项目，自己能全部答出来，然后他俩什么都不会，然后就凉了我是真的无语，进入到二辩。傻吊班主任，我是真的烦你。二辩走过场，但也很烦。 关于住宿或许是公司惜才（雾现在住在员工宿舍，4人间只住两个，目前还算舒适。 接下来的计划买个MacBookPro，毕竟一直以来的想法还是要实现的。我不会放弃前端的。 2018/4/5]]></content>
      <categories>
        <category>Whisper</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuejs学习笔记04]]></title>
    <url>%2F2018%2F03%2F27%2FVuejs04%2F</url>
    <content type="text"><![CDATA[v-bind及class与style绑定在数据绑定中，最常见的两个需求就是元素的样式名称class和内联样式style的动态绑定，它们也是HTML的属性，因此可以使用v-bind指令。我们只需用v-bind计算出表达式最终的字符串就可以，不过有时候表达式的逻辑较复杂，使用字符串拼接方法较难阅读和维护，所以Vue.js增强了对class和style的绑定。 绑定class的几种方式 对象语法&lt;div id=&quot;app&quot;&gt; &lt;div :class=&quot;&#123; &apos;active&apos;: isActive &#125;&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isActive: true &#125; &#125;)&lt;/script&gt; 如上，类名active依赖数据isActive，当其为true时，div会拥有类名Active，为false时则没有，所以得出渲染结果：&lt;div class=&quot;active&quot;&gt;&lt;/div&gt; class可以与语法糖:class共存&lt;div class=&quot;static&quot; :class=&quot;&#123; &apos;active&apos;: isActive, &apos;error&apos;: isError &#125;&quot;&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript摘抄]]></title>
    <url>%2F2018%2F03%2F27%2FJavaScript02%2F</url>
    <content type="text"><![CDATA[记笔记这种事从来不觉得累 依旧是基础 toUpperCase() 把一个字符串全部变大写 toLowerCase() 把一个字符串全部变小写 indexOf() 搜索字符串出现的位置 var s = 'hello,world';s.indexOf('world'); // 7 substring() 返回指定索引区间的子串 var s = 'hello world';s.substring(0,5); //从索引0开始到5（不包括5），返回hellos.substring(7); //从索引7开始到结束 获取Array的长度 var arr = [1,2,3,4,'hello',true,false];arr.lenght; //6 indexOf 搜索一个指定的元素的位置 var arr = [10,20,'30','xyz'];arr.indexOf(10); //索引为0arr.indexOf(30); //无元素30，返回-1 slice 对应string的substring(),截取Array的部分元素，返回新的Array var arr = ['A','B','C','D','E'];arr.slice(0,3); //['A','B','C']从0开始，到3结束，不包括3 若不给slice传递任何参数，它会全部截取，可以用作复制。 push和poppush()和Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉 var arr = [1,2];arr.push('A','B');arr; // [1,2,'A','B']arr.pop();arr; //[1,2,'A'] unshift和shift往Array头部添加若干元素，使用unshift()方法,shift()方法则把Array第一个元素删除掉 var arr = [1,2];arr.unshift('A','B');arr; // ['A','B',1,2]arr.shift();arr; // ['B',1,2] sort 对当前Array进行排序 reverse会把整个元素反转 splice方法是修改Array的万能方法它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素 var arr = ['Microsoft','Apple','Yahoo','AOL','Excite','Oracle'];//从索引2开始删除3个元素，然后再添加两个元素arr.splice(2,3,'Google','Facebook');//只删除，不添加arr.splice(2,2); concat()方法把当前的Array和赢一个Array连接起来 var arr = ['A','B','C'];var added = arr.concat([1,2,3]);added; //['A','B','C',1,2,3] join()方法join()方法会把当前Array的每个元素都用指定的字符串连接起来，然后返回字符串 var arr = ['A','B','C',1,2,3];arr.join('-'); // 'A-B-C-1-2-3' 多维数组如果数组的某个元素又是一个Array。则可以形成多维数组 var arr = [[1,2,3],[4,5,6],'-']; 对象 javascript的对象是一种无序的集合数据类型，它由若干键值对组成 var person = &#123; name: 'felix', birth: 1995, school: 'Suchou University', height: 175, weight: 73, score: null&#125;;person.age; //undefined 对于访问不存在的属性不报错，返回undefined由于Javascript的对象是动态类型，可以给一个对象添加或删除属性 person.age = 24;delete person.age; 检测person是否拥有某一属性，可以用in操作符 'name' in person; //true in只能检测是否有，而无法判断是否是继承来的对象，可以用hsaOwnProperty来检测是否是本身拥有的 person.hasOwnProperty('name'); 条件判断与循环和其他预览类似关于过滤对象继承是属性 var o = &#123; name: 'felix', age: 24, city: 'Beijing'&#125;;for (var key in o)&#123; if(o.hasOwnProperty(key))&#123; alert(key); // 'name','age','city' &#125;&#125; Map和Setjavascript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构 'use strict';var m = new Map();var s = new Set();alert('你的浏览器支持Map和Set'); Map Map是一组键值对的结构，具有极快的查找速度 var m = new Map([['Micheal',95],['Bob',75],['Tracy',85]]);m.get('Micheal'); //95 初始化Map需要一个二维数组，或者直接初始化一个空的Map var m = new Map(); //初始化一个空的Mapm.set('Adam',67); //添加新的key-valuem.set('Bob',59);m.has('Adam'); //判断是否存在key:'Adam',返回truem.get('Adam'); //67m.delete('Adam'); //删除key: 'Adam'm.get('Adam'); //undefined 一个key只能对应一个value，所以，多次一个key赋值，会把前面的覆盖掉 var m = new Map();m.set('Adam',67);m.set('Adam',88);m.get('Adam'); set set和Map类似，也是一组key的集合，但不存储value 要创建一个set,需要提供一个Array并输入，或者可以直接定义一个空的set var s1 = new Set([1,2,3]);var s2 = new Set(); 重复的key会在set中被自动过滤掉，使用add和delete来给set添加或删除 var s = new Set();s.add(4); var s = new Set([1,2,3]);s;s.delete(3);s; Iterable ES6引入的iterable类型，Array,Map,Set都属于iterable类型 具有iterable类型的集合可以通过新的for…of循环来遍历 var a = ['A','B','C'];var m = new Map([[1,'x'],[2,'y'],[3,'z']]);var s = new Set(['A','B','C']);for(let x of a) &#123; //遍历Array console.log(x);&#125;for(let x of s) &#123; //遍历Set console.log(x);&#125;for(let x of m) &#123; //遍历Map console.log(x[0] + '=' + x[1]);&#125; for…of和for…in的区别：for…in循环由于历史问题，实际上它遍历的是对象的属性名称，那么Array也是一种对象，Array的每个元素的下标被视为属性，当我们手动给Array添加额外的元素后，for…in循环会出现额外的情况var a = ['A','B','C'];a.name = 'Hello';for(var x in a) &#123; console.log(x); //0,1,2,name&#125; 而for…of循环解决了这个问题，它只遍历集合本身的元素var a = ['A','B','C'];a.name = 'Hello';for(var x of a) &#123; console.log(x); //'A','B','C'&#125; 在iterable中，还有一个内置方法forEach，它接收一个函数，每次迭代就自动回调该函数var a = ['A','B','C'];a.forEach(function(element,index,array)&#123; //element指向当前元素的值 //index指向当前索引 //array指向Array本身 console.log(element);&#125;) set与Array类似，但set没有索引，回调函数的前两个参数都是元素本身var s = new Set(['A','B','C']);s.forEach(function(element, sameElement, set) &#123; console.log(element);&#125;); Map的回调参数依次为value,key和map本身var m = new Map([[1,'x'],[2,'y'],[3,'z']]);m.forEach(function(value, key, map) &#123; console.log(value);&#125;); forEach的回调函数中的参数不必全部写完，只需要Array的元素值var a = ['A','B','C'];a.forEach(function(element) &#123; console.log(element);&#125;); 引自：JavaScript简明教程]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript小纪]]></title>
    <url>%2F2018%2F03%2F26%2FJavaScript01%2F</url>
    <content type="text"><![CDATA[一些闲来无事打的markdown JavaScript用法 JavaScript直接写入HTML输出流document.write(&quot;&lt;h1&gt;这是一个标题&lt;/h1&gt;&quot;)document.write(&quot;&lt;p&gt;这是一个段落&lt;/p&gt;&quot;) 可直接插入到HTML中 JavaScript对事件的反应 &lt;button type=&quot;button&quot; onclick=&quot;alert(&apos;欢迎&apos;)&quot;&gt;点击！&lt;/script&gt; JavaScript改变HTML内容 &lt;p id=&quot;demo&quot;&gt;JavaScript 能改变 HTML 元素的内容。&lt;/p&gt;&lt;script&gt;function myFunction()&#123; x=document.getElementById(&quot;demo&quot;); // 找到元素 x.innerHTML=&quot;Hello JavaScript!&quot;; // 改变内容&#125;&lt;/script&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt; DOM(Document Object Model)是用于访问HTML的W3C标准 JavaScript改变HTML图像 &lt;script&gt;function changeImage()&#123; element=document.getElementById(&apos;myimage&apos;) if (element.src.match(&quot;bulbon&quot;)) &#123; element.src=&quot;/images/pic_bulboff.gif&quot;; &#125; else &#123; element.src=&quot;/images/pic_bulbon.gif&quot;; &#125;&#125;&lt;/script&gt;&lt;img id=&quot;myimage&quot; onclick=&quot;changeImage()&quot;src=&quot;/images/pic_bulboff.gif&quot; width=&quot;100&quot; height=&quot;180&quot;&gt;&lt;p&gt;点击灯泡就可以打开或关闭这盏灯&lt;/p&gt; JavaScript改变HTML样式 &lt;p id=&quot;demo&quot;&gt;JavaScript 能改变 HTML 元素的样式。&lt;/p&gt;&lt;script&gt;function myFunction()&#123; x=document.getElementById(&quot;demo&quot;) // 找到元素 x.style.color=&quot;red&quot;; // 改变样式&#125;&lt;/script&gt;&lt;button type=&quot;button&quot; onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt; JavaScript验证输入 &lt;input id=&quot;demo&quot; type=&quot;text&quot;&gt;&lt;script&gt;function myFunction()&#123; var x=document.getElementById(&quot;demo&quot;).value; if(x==&quot;&quot;||isNaN(x)) &#123; alert(&quot;不是数字&quot;); &#125;&#125;&lt;/script&gt; JavaScript输出 使用window.alert()弹出警告框 使用document.write()将内容写入到HTML 使用innerHTML写入到HTML元素 使用console.log()写入到浏览器的控制台 JavaScript语法&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;var x, y, z;x = 5;y = 6;z = (x + y) * 10;document.getElementById(&quot;demo&quot;).innerHTML = z;&lt;/script&gt; 变量，操作符，关键字。 JavaScript函数 function myFunction(a, b) &#123; return a * b;&#125; 对代码进行换行，采用反斜杠document.write(&quot;你好 \ 世界&quot;); 变量 &lt;button onclick=&quot;myFunction()&quot;&gt;点击这里&lt;/button&gt;&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction()&#123; var carname=&quot;Volvo&quot;; document.getElementById(&quot;demo&quot;).innerHTML=carname;&#125;&lt;/script&gt; 创建名为carname的变量，赋值Volvo，然后将值放入demo里，插入到HTML中。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近着手换一套博客主题]]></title>
    <url>%2F2018%2F03%2F20%2FWhisper-3%2F</url>
    <content type="text"><![CDATA[应该架构还是采用Hexo 关于为什么会有这个想法或许是累了？或许是厌倦了随机缩略图，准备更大气一点目前还在四处收集东西，争取早日完工吧可怜我又要重新建分支了–]]></content>
      <categories>
        <category>Whisper</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuejs学习笔记03]]></title>
    <url>%2F2018%2F03%2F20%2FVuejs03%2F</url>
    <content type="text"><![CDATA[计算属性 计算属性使用计算属性的目的是在遇到复杂逻辑时，避免臃肿和难以阅读与维护。&lt;div id="app"&gt; &#123;&#123; reversedText &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; text: '123,456' &#125;, computed: &#123; reversedText: function ()&#123; return this.text.split(',').reverse().join(','); &#125; &#125; &#125;)&lt;/script&gt; 所有计算属性都以函数的形式写在Vue实例内的computed选项内。 &lt;div id="app"&gt; 总价: &#123;&#123; prices &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; package1: [ &#123; name: 'iphome 7', price: 7199, count: 2 &#125;,&#123; name: 'ipad', price: 2888, count: 1 &#125; ], package2: [ &#123; name: 'apple', price: 3, count: 5 &#125;, &#123; name: 'banana', price: 2, count: 10 &#125; ] &#125;, computed: &#123; var prices = 0; for (var i = 0; i &lt; this.package1.length; i++)&#123; prices += this.package1 [i].price * this.package1[i].count; &#125; for (var i = 0; i &lt; this.package2.length; i++)&#123; prices += this.package2 [i].price * this.package2[i].count; &#125; return prices; &#125; &#125;)&lt;/script&gt; 当package1和package2发生变化，prices自动更新。每一个计算属性都包含一个getter和setter。 &lt;div id="app"&gt; 姓名：&#123;&#123; fullName &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; firstName: 'Jack', lastName: 'Green' &#125;, computed: &#123; fullName: &#123; get: function ()&#123; return this.firstName + '' + this.lastName; &#125;, set: function (newValue) &#123; var names = newValue.split(' '); this.firstName = names[0]; this.lastName = names[names.length -1]; &#125; &#125; &#125; &#125;);&lt;/script&gt; 当执行app.fullName=’John Doe’时，setter就会被调用，视图随之更新。 计算属性缓存调用methods方法也可以与计算属性起同样作用。&lt;div id="app"&gt; &#123;&#123; reversedText() &#125;&#125;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; text: '123,456' &#125;, methods: &#123; reversedText: function ()&#123; return this.text.split(',').reverse().join(','); &#125; &#125; &#125;)&lt;/script&gt; methods里定义一个方法实现了相同效果，还可接受参数，使用灵活，那为何还要使用计算属性？计算属性是基于它的依赖缓存的，当数据发送变化时，它才会重新取值，只要text不改变，计算属性就不更新。]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[转换思路，抛弃拼接，参数传值]]></title>
    <url>%2F2018%2F03%2F19%2FSqlServer01%2F</url>
    <content type="text"><![CDATA[拼接方式写Sql语句最近真是让我头大啊 最近在写有关SqlServer增删改查多表联动拼接有点烦啊，虽然构建起来简单，但是问题真是层出不穷（或许是因为我太菜了考虑了好多遍，然后把全部都改成了参数方式，话说真的简单了很多个人理解可能会有点青涩，但所有不都是从青涩起步的话不多说，先贴上我写的来看看if (e.CommandName == &quot;Delete&quot;)&#123; string ProgramName = Grid1.DataKeys[e.RowIndex][0].ToString(); SqlParameter[] sqlparams = new SqlParameter[1]; sqlparams[0] = new SqlParameter(&quot;ProgramName&quot;, ProgramName); string sql = &quot;select ProgramName,Manager from ProgramError_ProgramManager Where ProgramName=@ProgramName&quot;; DataTable dt = DbHelperSQL.Query(sql, sqlparams).Tables[0]; if (dt.Rows.Count == 0) &#123; string sql2 = &quot;delete from ProgramError_ProgramName where ProgramName=@ProgramName&quot;; DbHelperSQL.ExecuteSql(sql2, sqlparams); string sql3 = &quot;delete from ProgramError_AlertPeople where ProgramName=@ProgramName&quot;; DbHelperSQL.ExecuteSql(sql3, sqlparams); Grid1Bind(); &#125; else &#123; Alert.Show(&quot;該類型下已有對應管理員，請先刪除類型對應管理員再執行刪除操作！&quot;); &#125;&#125; 一个简单的条件判断，当执行删除操作时，先判断另一张表是否存在对应管理员，存在则不允许删除本来准备Sql2和Sql3用一句解决的，但是测试几遍都没成，还需要多加学习啊- -还有一个关于分页的写法，记录一下sql = &quot;select ID,ProgramName,Manager from ProgramError_ProgramManager&quot;;string sql2 = &quot;select isnull(count(*),0) from (&quot; + sql + &quot;) ProgramError_ProgramManager&quot;;DataTable dtcount = DbHelperSQL.Query(sql2).Tables[0];Grid1.RecordCount = Convert.ToInt32(dtcount.Rows[0][0].ToString());int startIndex = Grid1.PageIndex * Convert.ToInt32(ddlGridPageSize.SelectedValue) + 1;int EndIndex = (Grid1.PageIndex + 1) * Convert.ToInt32(ddlGridPageSize.SelectedValue);sql = &quot;SELECT * FROM (SELECT ROW_NUMBER() OVER (order by ProgramName) as row,* from (&quot; + sql + &quot; )A )B where row between &quot; + startIndex.ToString() + &quot; and &quot; + EndIndex.ToString();DataSet ds = DbHelperSQL.Query(sql);Grid1.DataSource = ds.Tables[0];Grid1.DataBind();sql = &quot;select ProgramName from ProgramError_ProgramName&quot;;DataTable dt = DbHelperSQL.Query(sql).Tables[0];ddl_ProgramName.DataTextField = &quot;ProgramName&quot;;ddl_ProgramName.DataValueField = &quot;ProgramName&quot;;ddl_ProgramName.DataSource = dt;ddl_ProgramName.DataBind(); 这个学习过程，说起来是挺轻松的，可能只是最简单的sql操作，还是学到了不少，很开心]]></content>
      <categories>
        <category>SqlServer</category>
      </categories>
      <tags>
        <tag>Sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备案那些事儿]]></title>
    <url>%2F2018%2F03%2F19%2FWhisper-2%2F</url>
    <content type="text"><![CDATA[最近在忙备案的事情 真的过程是很繁琐这前后差不多一个星期，终于把材料寄了过去话说阿里云速度是挺快的，照片审核秒过不过我有个尴尬的地方，我只买了个轻量服务器，没有把项目部署到上面如果查网站内容我这就坑了–我真的只是准备目前把域名解析到GitHub 对了，域名是firelight.top]]></content>
      <categories>
        <category>Whisper</category>
      </categories>
      <tags>
        <tag>备案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyResume]]></title>
    <url>%2F2018%2F03%2F19%2FMyResume%2F</url>
    <content type="text"><![CDATA[很久没做过简历了 个人信息 杨金科/男/1995 本科/苏州大学应用技术学院软件工程（嵌入式培养） 应届生 技术博客：https://taylorfelix.github.io/ Github：https://github.com/TaylorFelix 期望职位：WEB前端工程师 期望薪资：税前月薪6k~10k 联系电话：18896825060 Email：m18896825060@163.com 微信：a1023614047 实习情况昆山淳华科技公司 （ 2018年1月 ~ 2018年4月 ）企业微信Oauth2验证结合企业微信官方开发文档，采用php调用API，实现了企业微信加入先跳转到企业自己页面进行身份验证，验证成功后加入企业微信。在这个项目中，关于接口调用及验证实现加深了我对API的理解及Json的使用。 C#+SqlServer进行WEB页面维护接手到此项目，从对C#一无所知，到熟练构建WEB页面与数据库多表查询删除操作，使我对于数据库操作了解更加深入。 项目经历基于SpringMVC水上乐园电子门票后台系统毕业设计课题，小组开发，主要负责UI，使用H5+Bootstrap进行页面构建，参与数据表设计。 个人博客（TaylorFelix.github.io）个人博客搭建，博客功能完善，Markdown博客书写，域名备案。 技能清单 Web开发：PHP 前端框架：Bootstrap/HTML5/Vuejs 数据库相关：MySQL/SqlServer 版本管理、文档和自动化部署工具：Git/Composer 致谢感谢您花时间阅读我的简历，期待能够得到同您面谈/面试的机会。]]></content>
      <categories>
        <category>简历</category>
      </categories>
      <tags>
        <tag>简历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuejs学习笔记02]]></title>
    <url>%2F2018%2F03%2F19%2FVuejs02%2F</url>
    <content type="text"><![CDATA[指令与事件 指令与事件指令的主要职责就是当其表达式的值改变时，相应地将某些行为应用到DOM上。&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;显示文本&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; show: true &#125; &#125;)&lt;/script&gt; 当数据show的值为true时，p元素会被插入。数据驱动DOM是Vue.js的核心理念。&lt;div id=&quot;app&quot;&gt; &lt;a v-bind:href=&quot;url&quot;&gt;链接&lt;/a&gt; &lt;img v-bind:src=&quot;imgUrl&quot;&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; url: &apos;https://www.github.com&apos;, imgUrl: &apos;http://xxx.xxx.xx/img.png&apos; &#125; &#125;)&lt;/script&gt; 如上，链接与图片均进行了数据绑定。```&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;show&quot;&gt;显示文本&lt;/p&gt; &lt;button v-on:click=&quot;handleClose&quot;&gt;点击隐藏&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: &apos;#app&apos;, data: &#123; show: true &#125;, methods: &#123; handleClose: function ()&#123; this.show = false; &#125; &#125; &#125;)&lt;/script&gt; 在button按钮上，使用v-on:click给该元素绑定了一个点击事件，v-on可以监听原生的DOM事件。 语法糖&lt;a v-bind:href=&quot;url&quot;&gt;链接&lt;/a&gt;&lt;img v-bind:src=&quot;imgUrl&quot;&gt;&lt;!--缩写为--&gt;&lt;a :href=&quot;url&quot;&gt;链接&lt;/a&gt;&lt;img :src=&quot;imgUrl&quot;&gt; v-on可以直接用@来缩写 &lt;button v-on:click=&quot;handleClose&quot;&gt;点击隐藏&lt;/button&gt;&lt;!--缩写为--&gt;&lt;button @click=&quot;handleClose&quot;&gt;点击隐藏&lt;/button&gt;]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuejs学习笔记01]]></title>
    <url>%2F2018%2F03%2F17%2FVuejs01%2F</url>
    <content type="text"><![CDATA[实例与数据绑定 真的难受啊，无论怎么都上传不了这一篇，说是markdown编码冲突，我还在研究，只能先上图了]]></content>
      <categories>
        <category>Vuejs</category>
      </categories>
      <tags>
        <tag>Vuejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object-C入门(三)]]></title>
    <url>%2F2018%2F03%2F12%2FObject-C03%2F</url>
    <content type="text"><![CDATA[循环结构的使用似乎都是一个样子 简直都让人不想写 for 先求初始表达式的值 求循环条件的值 执行组成循环体的程序语句 求循环表达式的值 返回到第二步键盘输入 scanf (); 嵌套的for循环 for ()&#123; for()&#123; &#125;&#125; for循环的变体 for(i=0,j=100;i&lt;10;++i,j-=10) while while ()&#123;&#125; dodo语句只是while语句的简单转置，它把循环条件放在循环的结尾，而不是开头。 break语句满足特定条件就退出循环 break; continue语句与break语句类似，但它不会使循环结束，会跳过该句直到循环结尾处之间的所有语句。 switch switch ()&#123; case value1: break; case value2: break; default: break;&#125;]]></content>
      <categories>
        <category>Object-C</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object-C入门(二)]]></title>
    <url>%2F2018%2F03%2F12%2FObject-C02%2F</url>
    <content type="text"><![CDATA[数据类型及常量 简单梳理一下 int类型整数常量由一个或多个数字的序列组成。 序列前的负号表示该值是负数。 float类型声明为float类型的变量可以存储包含小数位的值，如果要显示浮点值，可用NSLog转换字符%f或者%g。浮点常量也能用所谓的科学计数法来表示。值1.7e4代表1.7*10^4。 char类型char变量可存储单个字符。将字符放入一对单引号中就能得到字符常量。‘\n’换行符是一个合法的字符常量。 &#123;int integerVal =100;float floatingVar =331.79;double doubleVar =8.44e+11;char charVar =&apos;w&apos;;NSLog (@&quot;integerVal =%i&quot;,integerVal);NSLog (@&quot;floatingVar =%f&quot;,floatingVar);NSLog (@&quot;doubleVar =%e&quot;,doubleVar);NSLog (@&quot;doubleVar =%g&quot;,doubleVar);NSLog (@&quot;charVar =%c&quot;,charVar);&#125; 限定词：long,long long,short,unsigned,signed long int factorial; 这句将变量factorial声明为Long的整形变量。 id类型id数据类型可存储任何类型的对象。 id graphicObject; 将graphicObject声明为id类型的变量。可声明方法使其具有id类型的返回值，如下: -(id) newObject: (int) type; 这个程序行声明了一个名为newObject的实例方法，它具有type的单个整形参数并有id类型的返回值。 算术表达式 运算符的优先级如加减乘除一致优先级 整数运算和一元负号运算符与其他运算符相比，一元负号运算符具有更高的优先级。 模运算符 %模运算符的优先级与乘法和除法的优先级相等。 整型值和浮点值的相互转换 i1 = f1; //浮点数到整数的转换NSLog(@&quot;%f assigned to an int produces %i&quot;,f1,i1);f1 = i2; //整数到浮点数的转换NSLog(@&quot;%i assigned to a float produces %f&quot;,i2,f1); 类型转换运算符类型转换运算符通常用于将一般id类型的对象转换成特定类的对象。 id myNumber;Fraction *myFraction;...myFraction = (Fraction *) myNumber; 将id变量myNumber的值强制类型转换成一个Fraction对象。转换结果赋给Fraction变量myFraction。 赋值运算符Object-C语言允许使用以下的一般格式将算术运算符和赋值运算符合并到一起 op= 在这个格式中，op是任何算术运算符，还可以是任何用于移位和屏蔽操作的位运算符。 Calculator类#import &lt;Foundation/Foundation.h&gt;@interface Calculator: NSObject-(void) setAccumulator: (double) value;-(void) clear;-(double) accumulator;-(void) add: (double) value;-(void) subtract: (double) value;-(void) multiply: (double) value;-(void) divide: (double) value;@end@implementation Calculator&#123; double accumulator;&#125;-(void) setAccumulator:(double)value&#123; accumulator=value;&#125;-(void) clear&#123; accumulator = 0;&#125;-(double) accumulator&#123; return accumulator;&#125;-(void) add:(double) value&#123; accumulator +=value;&#125;-(void) subtract:(double)value&#123; accumulator -=value;&#125;-(void) multiply:(double)value&#123; accumulator *=value;&#125;-(void) divide:(double)value&#123; accumulator /=value;&#125;@endint main (int argc, char *argv[])&#123; @autoreleasepool &#123; Calculator *deskCalc = [[Calculator alloc] init]; [deskCalc setAccumulator:100.0]; [deskCalc add:200.]; [deskCalc divide:15.0]; [deskCalc subtract:10.0]; [deskCalc multiply:5]; NSLog(@&quot;The result is %g&quot;,[deskCalc accumulator]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Object-C</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Object-C入门(一)]]></title>
    <url>%2F2018%2F03%2F11%2FObject-C01%2F</url>
    <content type="text"><![CDATA[object-c中类、对象和方法的简单应用与实现 简单的应用//main.m#import &lt;Foundation/Foundation.h&gt;//----@interface部分----//用于描述类和类的方法,为类声明实例变量@interface Fraction: NSObject-(void) print; //通知编译器这是一个实例方法//-(int) currentAge 可以声明返回值的类型。-(void) setNumerator:(int) n;//不返回值的实例方法，定义参数名n，将方法传递给n这个整形参数，且没有返回值。-(void) setDenominator:(int) d;@end//----@implementation部分----//用于描述数据（类对象的实例变量存储的数据）@implementation Fraction&#123; int numerator; int denominator; //指定哪种类型的数据将要存储到Fraction中&#125;-(void) print;&#123; NSLog(@&quot;%i/%i&quot;,numerator,denominator);&#125;-(void) setNumerator: (int) n&#123; numerator = n;&#125;-(void) setDenominator: (int) d&#123; denominator = d;&#125;@end//----program部分----//实现程序预期的目的，包含解决特定问题的代码，可跨越多个文件int main (int argc, char * argv[])&#123; @autoreleasepool &#123; Fraction *myFraction; //*表明myFraction是Fraction对象的引用（或指针） //创建一个分数实例 myFraction = [Fraction alloc]; //alloc为新分数分配内存存储空间 myFraction = [myFraction init]; //初始化实例变量 //简写形式 Fraction *myFraction = [[Fraction alloc] init]; //设置分数为1/3 [myFraction setNumerator: 1]; [myFraction setDenominator: 3]; //使用打印方法打印结果 NSLog(@&quot;The value of myFraction is:&quot;); [myFraction print]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Object-C</category>
      </categories>
      <tags>
        <tag>Object-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于sql server的增删改查]]></title>
    <url>%2F2018%2F03%2F10%2FCsharp-1%2F</url>
    <content type="text"><![CDATA[一个简单的报警维护页面 采用Fineui,C#,SQLServer完成 开发工具 Visual Studio 开发成果 如图所有功能均可实现 输入类别（必须）和备注后点击新增将数据插入数据库并呈现在下表中 输入关键字可进行查询，查询结果在下表中展示 点击删除，提示是否删除，确定后删除成功 开发流程 首先添加一个新建项 构造前端页面（基于FineUI） &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt; &lt;f:PageManager ID=&quot;PageManager1&quot; AutoSizePanelID=&quot;Panel1&quot; runat=&quot;server&quot; /&gt; &lt;f:Panel ID=&quot;Panel1&quot; runat=&quot;server&quot; BodyPadding=&quot;5px&quot; ShowBorder=&quot;false&quot; Layout=&quot;VBox&quot; BoxConfigAlign=&quot;Stretch&quot; BoxConfigPosition=&quot;Start&quot; ShowHeader=&quot;false&quot; Title=&quot;報警維護&quot;&gt; &lt;Items&gt; &lt;f:Form ID=&quot;Form&quot; runat=&quot;server&quot; ShowHeader=&quot;false&quot; ShowBorder=&quot;false&quot; LabelWidth=&quot;90px&quot;&gt; &lt;Rows&gt; &lt;f:FormRow&gt; &lt;Items&gt; &lt;f:Label ID=&quot;Label2&quot; Text=&quot;&quot; Width=&quot;100&quot; MarginRight=&quot;8&quot; runat=&quot;server&quot;&gt; &lt;/f:Label&gt; &lt;/Items&gt; &lt;/f:FormRow&gt; &lt;/Rows&gt; &lt;/f:Form&gt; &lt;f:Grid ID=&quot;Grid1&quot; runat=&quot;server&quot; BoxFlex=&quot;1&quot; ShowBorder=&quot;true&quot; ShowHeader=&quot;false&quot; DataKeyNames=&quot;ProgramName,ErrorMessage&quot; EnableRowDoubleClickEvent=&quot;true&quot; OnRowCommand=&quot;Grid1_RowCommand&quot; OnRowDoubleClick=&quot;Grid1_RowDoubleClick&quot;&gt; &lt;Toolbars&gt; &lt;f:Toolbar ID=&quot;Toolbar1&quot; runat=&quot;server&quot;&gt; &lt;Items&gt; &lt;f:TextBox ID=&quot;tbProgramName&quot; runat=&quot;server&quot; Label=&quot;報警類別&quot; LabelWidth=&quot;70px&quot; Width=&quot;260px&quot; TabIndex=&quot;1&quot;&gt;&lt;/f:TextBox&gt; &lt;f:TextBox ID=&quot;tbErrorMessage&quot; runat=&quot;server&quot; Label=&quot;信息備註&quot; LabelWidth=&quot;70px&quot; Width=&quot;260px&quot; TabIndex=&quot;1&quot;&gt;&lt;/f:TextBox&gt; &lt;/Items&gt; &lt;/f:Toolbar&gt; &lt;f:Toolbar ID=&quot;Toolbar2&quot; runat=&quot;server&quot;&gt; &lt;Items&gt; &lt;f:Button ID=&quot;btnSave&quot; runat=&quot;server&quot; Text=&quot;新增&quot; OnClick=&quot;btnSave_Click&quot; Icon=&quot;Add&quot; ValidateForms=&quot;Form&quot; &gt;&lt;/f:Button&gt; &lt;f:Button ID=&quot;btnSearch&quot; runat=&quot;server&quot; Text=&quot;查詢&quot; OnClick=&quot;btnSearch_Click&quot; Icon=&quot;Zoom&quot; &gt;&lt;/f:Button&gt; &lt;f:HiddenField ID=&quot;hidLx&quot; runat=&quot;server&quot;&gt;&lt;/f:HiddenField&gt; &lt;f:HiddenField ID=&quot;HidCb&quot; runat=&quot;server&quot;&gt;&lt;/f:HiddenField&gt; &lt;f:HiddenField ID=&quot;HidQxDm&quot; runat=&quot;server&quot;&gt;&lt;/f:HiddenField&gt; &lt;f:HiddenField ID=&quot;HidDeptId&quot; runat=&quot;server&quot;&gt;&lt;/f:HiddenField&gt; &lt;/Items&gt; &lt;/f:Toolbar&gt; &lt;/Toolbars&gt; &lt;Columns&gt; &lt;f:RowNumberField Width=&quot;40px&quot; /&gt; &lt;f:BoundField DataField=&quot;ProgramName&quot; HeaderText=&quot;報警類別&quot; Width=&quot;100px&quot; HeaderTextAlign=&quot;Center&quot; /&gt; &lt;f:BoundField DataField=&quot;ErrorMessage&quot; HeaderText=&quot;信息維護&quot; Width=&quot;100px&quot; HeaderTextAlign=&quot;Center&quot; /&gt; &lt;f:BoundField DataField=&quot;C_USER&quot; HeaderText=&quot;錄入人&quot; Width=&quot;160px&quot; HeaderTextAlign=&quot;Center&quot; /&gt; &lt;f:BoundField DataField=&quot;C_Date&quot; HeaderText=&quot;錄入時間&quot; Width=&quot;140px&quot; DataFormatString=&quot;&#123;0:yyyy/MM/dd&#125;&quot; HeaderTextAlign=&quot;Center&quot; /&gt; &lt;f:BoundField DataField=&quot;U_USER&quot; HeaderText=&quot;更新人&quot; Width=&quot;160px&quot; HeaderTextAlign=&quot;Center&quot; /&gt; &lt;f:BoundField DataField=&quot;U_Date&quot; HeaderText=&quot;更新時間&quot; Width=&quot;160px&quot; DataFormatString=&quot;&#123;0:yyyy/MM/dd&#125;&quot; HeaderTextAlign=&quot;Center&quot; /&gt; &lt;f:LinkButtonField ColumnID=&quot;deleteField&quot; TextAlign=&quot;Center&quot; Icon=&quot;Delete&quot; HeaderText=&quot;刪除&quot; ToolTip=&quot;刪除&quot; ConfirmText=&quot;確定刪除？&quot; ConfirmTarget=&quot;Self&quot; CommandName=&quot;Delete&quot; Width=&quot;100px&quot;&gt;&lt;/f:LinkButtonField&gt; &lt;/Columns&gt; &lt;/f:Grid&gt; &lt;/Items&gt; &lt;/f:Panel&gt; &lt;/form&gt; 前端构造也就都那么回事，看着长主要是在做格式。 功能实现通过前端各个数据的绑定，进行后端数据的书写。 protected void Page_Load(object sender, EventArgs e)&#123; Grid1Bind();&#125;private void Grid1Bind()&#123; string strDept = &quot; select ProgramName,ErrorMessage,C_user,C_DATE,U_user,U_DATE from ProgramError_ProgramName where ProgramName like &apos;%&quot; + tbProgramName.Text.Trim() + &quot;%&apos; and ErrorMessage like &apos;%&quot; + tbErrorMessage.Text.Trim() + &quot;%&apos;&quot;; DataTable dt = DbHelperSQL.Query(strDept).Tables[0]; Grid1.DataSource = dt; Grid1.DataBind(); // 查詢programerror_programname表內所有programname數據&#125;protected void Grid1_RowCommand(object sender, GridCommandEventArgs e)&#123; DataTable dt = Grid1.DataSource as DataTable; string programname = Grid1.DataKeys[e.RowIndex][0].ToString(); // 選取programname所在行 if (e.CommandName == &quot;Delete&quot;) &#123; string sql = &quot;delete from ProgramError_ProgramName where programName =&apos;&quot; + dt.Rows[e.RowIndex][&quot;programName&quot;].ToString() + &quot;&apos;&quot;; DbHelperSQL.ExecuteSql(sql); Grid1Bind(); &#125;; // command事件觸發delete，執行刪除數據&#125;protected void btnSearch_Click(object sender, EventArgs e)&#123; Grid1Bind();&#125;protected void btnSave_Click(object sender, EventArgs e)&#123; if (tbProgramName.Text.Trim() == &quot;&quot;) &#123; Alert.Show(&quot;報警類別不能為空!&quot;); return; &#125; StringBuilder sb = new StringBuilder(); if (hidLx.Text.Trim() == &quot;&quot;) &#123; string strSql = &quot;select * from [ProgramError_ProgramName] where ProgramName =&apos;&quot; + tbProgramName.Text.Trim() + &quot;&apos; and [ErrorMessage]=&apos;&quot; + tbErrorMessage.Text.Trim().Trim() + &quot; &apos; &quot;; DataTable dt = DbHelperSQL.Query(strSql).Tables[0]; if (dt.Rows.Count &gt; 0) &#123; Alert.Show(&quot;要保存的報警類別已存在，請不要重新增加！&quot;); return; &#125; sb.AppendLine(&quot; insert into ProgramError_ProgramName (ProgramName,ErrorMessage,C_user,C_DATE) &quot;); sb.AppendLine(&quot; values (N&apos;&quot; + tbProgramName.Text.Trim() + &quot;&apos;,&apos;&quot; + tbErrorMessage.Text.Trim().Trim() + &quot;&apos; &quot;); sb.AppendLine(&quot; ,&apos;&quot; + GetIdentityName() + &quot;&apos;,getdate() )&quot;); &#125; else &#123; sb.AppendLine(&quot; update ProgramError_ProgramName set ProgramName =&apos;&quot; + tbProgramName.Text.Trim() + &quot;&apos;,ErrorMessage=&apos;&quot; + tbErrorMessage.Text.Trim().Trim() + &quot;&apos; &quot;); sb.AppendLine(&quot; ,U_USER=&apos;&quot; + GetIdentityName() + &quot;&apos;,U_DATE=getdate() &quot;); sb.AppendLine(&quot; where ProgramName =&apos;&quot; + HidCb.Text.Trim() + &quot;&apos; &quot;); &#125; try &#123; int rows = DbHelperSQL.ExecuteSql(sb.ToString()); if (rows &gt; 0) &#123; tbProgramName.Text = &quot;&quot;; tbProgramName.Enabled = true; tbErrorMessage.Text = &quot;&quot;; hidLx.Text = &quot;&quot;; Grid1Bind(); Alert.Show(&quot;添加成功！&quot;); &#125; &#125; catch (Exception ex) &#123; Alert.Show(&quot;添加失敗:&quot; + ex); return; &#125;&#125;protected void Grid1_RowDoubleClick(object sender, GridRowClickEventArgs e)&#123; hidLx.Text = &quot;1&quot;; HidCb.Text = Grid1.DataKeys[e.RowIndex][0].ToString(); tbProgramName.Enabled = false; tbProgramName.Text = Grid1.DataKeys[e.RowIndex][0].ToString(); tbErrorMessage.Text = Grid1.DataKeys[e.RowIndex][1].ToString();&#125; 代码真多–用了将近一星期吸收理解sql server have a nice day!]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次企业微信二次验证开发]]></title>
    <url>%2F2018%2F03%2F06%2FPhp-1%2F</url>
    <content type="text"><![CDATA[如何合理运用微信api的二次验证与回调 关于二次验证首先要确保企业微信开启了二次验证 构造链接 关于这方面的东西太多了，可以去企业微信开发文档查看，这里不再多加赘述。 主要聊一下开发的部分。 应用于实际需求仅仅是开启企业通讯录然后进行导入是不切实际的，不同公司数据库格式也不同，导出问题也是头疼。幸好公司大手结合网上大佬给出的验证（在此膜拜一下云哥），实现了二次验证。 我们需要满足的需求 员工收到企业微信邀请 点击跳转到企业微信 企业微信跳转到我们自定义的信息录入界面 完成信息录入跳转回企业微信 话不多说，贴代码本需求的实现采用php+mysql首先掏出我们构造链接的php文档reg.php&lt;?phpdefine(&quot;CORPID&quot;,&quot;&quot;); //企业微信上的设置中的找到这个参数define(&quot;CORPSECRET&quot;,&quot;&quot;); //企业微信上的设置-权限管理-应用权限开发者凭据找这个参数$token_access_url = &quot;https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=&quot;.CORPID.&quot;&amp;corpsecret=&quot;.CORPSECRET;$res = file_get_contents($token_access_url);$arr_result = json_decode($res,true);define(&quot;ACCESS_TOKEN&quot;,$arr_result[&apos;access_token&apos;]);define(&quot;CODE&quot;, $_GET[&apos;code&apos;]);define(&quot;state&quot;,$_GET[&apos;state&apos;]); $make_menu_url = &quot;https://qyapi.weixin.qq.com/cgi-bin/user/getuserinfo?access_token=&quot;.ACCESS_TOKEN.&quot;&amp;code=&quot;.CODE.&quot;&amp;agentid=0&quot;;$res2 = file_get_contents($make_menu_url);$arr_result2 = json_decode($res2,true);define(&quot;USERID&quot;, $arr_result2[&apos;UserId&apos;]);?&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;人员信息验证&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;h1&gt;人员信息验证&lt;/h1&gt; &lt;FORM name=&quot;submit&quot; action=&quot;index.php&quot; method=&quot;POST&quot;&gt; &lt;div class=&quot;enter&quot;&gt; &lt;input type=&quot;text&quot; placeholder=&quot;工号&quot; name=&apos;username&apos;&gt; &lt;input type=&quot;password&quot; placeholder=&quot;身份证号&quot; name=&apos;pass&apos;&gt; &lt;input type=&quot;hidden&quot; value= &lt;?php echo ACCESS_TOKEN; ?&gt; placeholder=&quot;access_token&quot; name=&apos;access_token&apos;&gt; &lt;input type=&quot;hidden&quot; value= &lt;?php echo USERID; ?&gt; placeholder=&quot;userid&quot; name=&apos;userid&apos;&gt; &lt;input type=&quot;submit&quot; value=&quot;确认&quot; name=&quot;Submit&quot; class=&quot;btn_submit&quot;&gt; &lt;/div&gt; &lt;/FORM&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 此时已经实现了数据绑定跳转到```index.php&lt;?php $emp_no=$_POST[&apos;username&apos;]; $shengfenzheng=$_POST[&apos;pass&apos;]; $access_token=$_POST[&apos;access_token&apos;]; $userid=$_POST[&apos;userid&apos;]; $link = mysqli_connect(&apos;yourhost&apos;,&apos;&apos;,&apos;&apos;,&apos;database&apos;); $query=mysqli_query($link,&quot;insert into wechatqiye(name_id,emp_no)value(&apos;$userid&apos;,&apos;$emp_no&apos;)&quot;);//找到与输入用户名相同的信息，注意要取出的信息有两项 if($query)&#123; $send_url = &quot;https://qyapi.weixin.qq.com/cgi-bin/user/authsucc?access_token=&quot;.$access_token.&quot;&amp;userid=&quot;.$userid.&quot;&quot;; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $send_url); curl_setopt($ch, CURLOPT_CUSTOMREQUEST, &quot;GET&quot;); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER,FALSE); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST,FALSE); curl_setopt($ch, CURLOPT_USERAGENT,&apos;Mozilla/5.0 (compatible; MSIE 5.01;Windows NT 5.0)&apos;); curl_setopt($ch, CURLOPT_FOLLOWLOCATION,1); curl_setopt($ch, CURLOPT_AUTOREFERER,1); // curl_setopt($ch, CURLOPT_POSTFIELDS, $userid); curl_setopt($ch, CURLOPT_RETURNTRANSFER,true); $info = curl_exec($ch); if(curl_errno($ch))&#123; echo &apos;Errno&apos;.curl_error($ch); &#125; curl_close($ch); print_r($info); echo &quot;&lt;script language=JavaScript&gt;alert(&apos;驗證成功&apos;);&lt;/script&gt;&quot;; &#125; else &#123; echo &quot;&lt;script language=JavaScript&gt;alert(&apos;驗證失敗請重新認證&apos;);&lt;/script&gt;&quot;; &#125;?&gt; 以上]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo踩坑指北]]></title>
    <url>%2F2018%2F03%2F06%2FBlog-3%2F</url>
    <content type="text"><![CDATA[HEXO在windows上真是不断的坑啊– 关于多台电脑更新之前有写过一篇，最近准备不在公司电脑上写，换到自己电脑上，各种操作过后，出现了及其尴尬的现象。 我特么。。。按照网上各种百度以及stackflow–wtf？？？并不管用好吗？ 诸如ssh -T git@github.com 诚心诚意的告诉你，并没有卵用 还有这种在你电脑上给git配置环境变量拜托，我都测试过很多遍了，别来坑我了好吗？ ——–华丽的分割线——–下面介绍真正管用的方法首先你要确保你d -g```这个操作前```_config.yml```文件里 deploy: type: git repository: github: git@github.com:TaylorFelix/TaylorFelix.github.io.git coding: git@git.coding.net:taylorfelix/taylorfelix.coding.me.git branch: master一定配置的要是ssh，别弄的什么https://github之类的然后，你需要放弃使用```cmd```，到你根目录，```git bush here 然后执行hexo d -g如果你和我一样配置了coding.net中间需要确认一次同步到coding接下来就美滋滋啦 以上。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缺钱]]></title>
    <url>%2F2018%2F03%2F02%2FWhisper-1%2F</url>
    <content type="text"><![CDATA[缺钱就像缺血一样 犹豫要不要换新电脑小米笔记本Air 13.3 i7 256GMacBookPro小米便宜，最近能还清Mac功能强大，太贵难受Fuck!]]></content>
      <categories>
        <category>Whisper</category>
      </categories>
      <tags>
        <tag>money</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS开发学习(二)]]></title>
    <url>%2F2018%2F02%2F28%2FIOS-2%2F</url>
    <content type="text"><![CDATA[关于运算符与表达式的学习 运算符运算符就像动词一样，可以导致变量发生变化 算术运算符常用二元算术运算符，加减乘除 + - * / 余数运算符余数或模(modules)运算符(%)用于计算整数除法的余数。int a = 7;int b = 3;int c = a%b; // c is now 1 递增和递减运算符a++;++a; 前缀版本++a在其他任何求值发生前递增a的值，在表达式的余下部分将使用递增后的值。后缀版本a++在其他求值发生之后递增a的值，在表达式的余下部分将使用原来的值。int a = 9;int b;b = a++;int c = 9;int d;d = ++c; 优先级理同数学优先级，乘法和除法具有比加法和减法更高的优先级。 取负运算符一元减号用于把一个算术值改为它的负值：int a = 9;int b;b = -a; // b is now -9 比较运算符a &gt; b // true, if a is greater than ba &lt; b // true, if a is less than ba &gt;= b // true, if a is greater than or equal to ba == b // true, if a is equal to ba != b // true, if a is not equal to b 逻辑运算符C语言使用短路求值法。表达式从左到右求值。if ( b &lt; a &amp;&amp; CheckSomething () ) &#123; ... &#125; 逻辑“非”运算符a = ! expression; 赋值运算符a = b; 把b的值赋予a。当然，a必须能够被赋值。可以赋值的实体称为左值，因为它们出现在赋值运算符的左边。/* set up */float a;float b[100];float *c;struct dailyTemperatures today;struct dailyTemperatures *todayPtr;c = &amp;a;todayPtr = &amp;today;/* legal lvalues */a = 76;b[0] = 76;*c = 76;today.high = 76;todayPtr-&gt;high = 76; 转换和强制转换通过使用强制转换，强制编译器会把变量的值转换成一种不同的类型。int a = 6;int b = 4;float c, d;c = a / b;d = ( float )a / ( float )b; float强制转换令强制编译器把a和b转换成float类型，并执行浮点型除法运算。 其他赋值运算符C语言还具有结合了算术和赋值运算的简写运算符：a += b; 等价于 a = a + b;a -= b; 等价于 a = a - b;a *= b; 等价于 a = a* b;a /= b; 等价于 a = a/ b; 表达式和语句C语言中的表达式和语句大致相当于自然语言中的短句和句子。 表达式最简单的表达式只有一个常量或变量：14bananasPerBunch 每个表达式都有一个值。j + 14a &lt; bdistance = rate * time 算术或逻辑表达式的值就是通过执行算术或逻辑运算所得到的任何值。赋值表达式的值就是赋予作为赋值目标的变量的值。SomeFunction() 函数调用表达式的值是该函数的返回值。 表达式求值编译器遇到表达式，创建二进制代码，用于计算表达式并求出它的值。 语句末尾添加分号;，变成语句。 复合语句&#123; timeDelta = time2 - time1; distanceDelta = distance2 - distance1; averageSpeed = distanceDelta / timeDelta;&#125; 闭大括号后面没有分号。这种语句称为复合语句。]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo多电脑更新博客]]></title>
    <url>%2F2018%2F02%2F28%2FGit-2%2F</url>
    <content type="text"><![CDATA[解决Hexo多电脑更新博客内容 1.准备工作首先确保自己已经使用hexo在github搭建好了自己的个人博客，github仓库中如下图显示： 2.对username.github.io仓库新建hexo分支，并克隆在Github的username.github.io仓库上新建一个xxx分支，并切换到该分支，并在该仓库-&gt;Settings-&gt;Branches-&gt;Default branch中将默认分支设为xxx，save保存；然后将该仓库克隆到本地，进入该username.github.io文件目录。 完成上面步骤后，在当前目录使用Git Bash执行git branch命令查看当前所在分支，应为新建的分支xxx： $ git branch*hexo 3.将本地博客的部署文件拷贝进username.github.io文件目录如题，先将本地博客的部署文件（Hexo目录下的全部文件）全部拷贝进username.github.io文件目录中去。 接下来，进入username.github.io文件目录下，将该目录下的全部文件提交到xxx分支，提交之前需注意： 将themes目录以内中的主题的.git目录删除（如果有），因为一个git仓库中不能包含另一个git仓库，提交主题文件夹会失败。 可能有人会问，删除了themes目录中的.git不就不能git pull更新主题了吗，很简单，需要更新主题时在另一个地方git clone下来该主题的最新版本，然后将内容拷到当前主题目录即可 4.提交hexo分支执行git add .、git commit -m &#39;back up hexo files&#39;（引号内容可改）、git push即可将博客的hexo部署环境提交到GitHub个人仓库的xxx分支。 master分支和xxx分支各自保存着一个版本，master分支用于保存博客静态资源，提供博客页面供人访问；xxx分支用于备份博客部署文件，供自己维护更新，两者在一个GitHub仓库内互不冲突，完美！ 5.宿舍自己的电脑至此，你的博客已经可以在其他电脑上进行同步的维护和更新了，方法很简单： 将新电脑的生成的ssh key添加到GitHub账户上 在新电脑上克隆username.github.io仓库的xxx分支到本地，此时本地git仓库处于xxx分支 切换到username.github.io目录，执行npm install(由于仓库有一个.gitignore文件，里面默认是忽略掉 node_modules文件夹的，也就是说仓库的hexo分支并没有存储该目录[也不需要]，所以需要install下) 到这里了就可以开始在自己的电脑上写博客了！ 编辑、撰写文章或其他博客更新改动 依次执行git add .、git commit -m &#39;back up hexo files&#39;（引号内容可改）、git push指令，保证xxx分支版本最新 执行hexo d -g指令（在此之前，有时可能需要执行hexo clean），完成后就会发现，最新改动已经更新到master分支了，两个分支互不干扰！ 6.原主电脑 注意： 每次换电脑进行博客更新时，不管上次在其他电脑有没有更新，最好先git pull 按照之前的方法写自己博客，然后将目录切换下username.github.io下，此时需要安装一下npm install，最后执行hexo g、hexo s、hexo d等命令即可提交成功]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOS开发学习(一)]]></title>
    <url>%2F2018%2F02%2F26%2FIOS-1%2F</url>
    <content type="text"><![CDATA[C程序的结构与变量 IOS开发学习新的起点 C程序的结构main例程所有c程序都有一个main例程。在OS加载第一个C程序后，程序开始执行main例程中的第一行代码。int main(int argc, const char *argv[])&#123;return 0;&#125; 关键特性包括: 第一行上的指导int提升main给OS返回一个整形值，作为返回代码 main是必需的 main接收argc个参数，存储在数组argv中 return 0; 指示将0作为返回代码传给OS简化形式：int main (void)&#123;&#125; 格式化语句用分号;终止 注释经典注释//封闭注释/**/ 变量和函数名称首字符采用下划线或字母以下划线开头的名称传统上用于打算设置为私有的或者供内部使用的变量和函数_privateVariable 名称区分大小写，且不能有任何空白驼峰式命名方式 文件朴素的C程序代码放在一个或多个拓展名为.c的文件中ACProgram.c 使用Object-C对象的代码放在一个或多个拓展名为.m的文件中AnObjectiveProgram.m C程序还使用头文件，头文件通常包含可以被许多.c和.m文件共享的多种定义。通过使用#include或#import预处理指令AHeaderFile.h 变量变量声明形式如下：variabletype name; C语言允许在单个声明中声明多个变量：variabletype name1,name2,name3; 整形C语言提供了以下类型用于保存整数：char、short、int、long、long long.可以把整形声明为unsigned:unsigned char a;unsigned short b;unsigned int c;unsigned long d;unsigned long long e; 单独使用unsigned时，意指 unsigned int:unsigned a; // a is an unsigned int unsinged通常赋值为正数。 浮点型浮点型是float、double、long double浮点值总是带符号的float aFloat;double aDouble;long double aLongDouble; 真值普通的表达式通常用于真值。求值为0的表达式被视为“假”，而求值为非0的表达式视为“真” 初始化可以在声明变量时初始化它们：int a=9;int b=2*4;float c=3.14159;char d=&apos;a&apos;; 指针指针是其值为一个内存地址的变量。它“指向”内存中的某个位置。声明一个指针，在变量名称前面放置一个*int *pointerVar; 泛型指针如果一个变量被声明为指向void的指针，那它成为泛型指针。int a=9;int b;void *genericPointer;genericPointer = &amp;a;b = *(( int *) genericPointer ); 上例使用强制转换运算符(int *)强制编译器把genericPointer视作一个指向整数的指针。 数组C数组是同类型元素的有序集合。int a[100]; 通过下面的方式访问各个元素a [6] = 9; 多维数组声明方式如下：int b[4][10]; 多维数组以线性方式逐行存储在内存中。使用指针表示法：b[i][j] 可能写作：*(b+i*10+j) 字符串C语言的字符串是字节的一维数组，并利用0字节终止。char *aString =&quot;Hello&quot;;aString = &quot;World&quot;; 结构结构可以成为单个实体的相关变量的集合。struct dailyTemperatures&#123; float high; float low; int year; int dayOfYear;&#125; 结构中各个变量称为成员变量。关键字struct后面的名称是结构标签。结构可以具有其他结构作为成员。struct hiLow&#123; float high; float low;&#125;;struct dailyTemperatures&#123; struct hiLow tempExtremes; int year; int dayOfYear;&#125;; 这样，设置today的高温将如下显示struct dailyTemperatures today;today.tempExtremes.high=68.0; typedeftypedef声明提供了一种用于为变量类型创建别名的方式：typedef float Temperature; Temperature可用于声明变量，就像它是内置的类型之一一样：Temperature high,low; 枚举常量enum语句允许定义一组整形常量：enum woodwind &#123; oboe,flute,clarinet,bassoon &#125;; 上句的结果是：obue、flute、clarinet、bassoon分别是值为0、1、2、3的常量。enum后面的名称成为枚举标签。]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>IOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[评论功能上线啦！]]></title>
    <url>%2F2018%2F02%2F26%2FBlog-1%2F</url>
    <content type="text"><![CDATA[评论功能的实现效果 评论及流量采集已上线 经过反复测试及部分崩坏，终于搞定了评论功能，先说一下评论需求开始的考量。 以下个人说法仅经过material主题测试。 1. Disqus 国外评论系统，需科学上网，pass 2. 畅言 域名需备案，暂时pass 3. 来必利 韩国人开发的评论系统，测试着用了一下，先说安装方法吧。 注册来必利账号 进入账号后台 点击代码管理 拷贝data-uid=”此处未需要拷贝的内容”&gt; 进入主题内的_config.yml配置文件 将comment: use:后改为livere 添加livere_data_uid:在后加入复制内容 以上功能请务必确保_widget/comment/下有livere这个文件夹 接下来说一下这个评论系统的尴尬之处 在refer处添加的评论系统，加载速度感人 评论必须登录第三方账号，游客类型恐怕留言兴趣都没有（哪有游客？不存在的） 丑 4. valine 主人公登场！ 这个评论系统应该是我个人感觉最满意的！ 无需登录！界面简洁！流量记录！ 迫不及待的安利起来了 注册leancloud账号 进入控制台 创建应用（默认JavaScript SDK） 创建class，名称为Counter ACL权限必须无限制 进入主题内的_config.yml配置文件 将comment: use:后改为valine 添加valine_leancloud_appId和valine_leancloud_appKey appId和appKey在leancloud设置-应用key里可以找到 顺便添加流量采集与流量分析 修改leadcloud enable:true（默认为false） 配置app_id与app_key，与valine一致。 以上功能请务必确保_widget/comment/下有valine这个文件夹 至此博客评论及流量采集已经完成，撒花~~~ 作者 Felix2018 年 02月 26日]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>Valine</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次Hexo同时部署GitHub和Coding]]></title>
    <url>%2F2018%2F02%2F26%2FBlog-2%2F</url>
    <content type="text"><![CDATA[如何优化加载速度与部署问题 Hexo同时部署GitHub和Coding GitHub加载速度实在是太慢了，静态资源加载可以说是等一年–参考部分大佬优化加载的方式，最后选择了coding这是原博Hexo博客优化加载速度 首先需要注册一个coding账号 傻瓜式操作不再多加说明 创建新项目 点击创建新项目，项目名称一定要是 你的用户名+coding.me 例如：taylorfelix.coding.me 点击Page服务 静态page-部署来源-master 部署ssh 点击部署公钥，添加ssh-rsa 此处ssh应与github部署的ssh一致 此处已完成coding所有配置 修改Hexo根目录_config.yml文件 直接拉到最底部，在deploy处配置 deploy: type: git repository: github: git@github.com:TaylorFelix/TaylorFelix.github.io.git coding: git@git.coding.net:taylorfelix/taylorfelix.coding.me.git branch: master 此处每个：后应空一格 配置完成开始部署 打开cmd（此处对于windows而言）,到你的项目目录 hexo d -g 完成部署 作者 Felix2018 年 02月 26日]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用命令采集]]></title>
    <url>%2F2018%2F02%2F24%2FGit-1%2F</url>
    <content type="text"><![CDATA[一些常用的Git指令 常用指令采集 Hexo与Git库同步（本地同步至git） hexo d -g Hexo运行测试预览 hexo s GitHub同步指令集 git init git add . git commit -m “此处为项目说明” git remote add origin 远程库地址 此处为关联远程数据库 git pull –rebase origin master此处为远程库与本地同步合并（若远程库不为空一定要做这一步） git -u origin master内容推送到远程（之后开始验证然后上传） git status状态查询 Git常用命令生成.ssh文件 ssh-keygen -t rsa -C “1023614047@qq.com“判断是否在本机配置远程连接成功 ssh -T git@github.com删除远程仓库 git remote rm origin更新本地仓库到github git push -u origin master将文件夹下所有文件添加到版本库 作者 Felix2018 年 02月 24日]]></content>
      <categories>
        <category>Study</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[产线环境体验]]></title>
    <url>%2F2018%2F02%2F24%2FWork-1%2F</url>
    <content type="text"><![CDATA[各在其位，各司其职 初体验厂企生产流程今天得有机会看了下产线的生产流程，伴随着浓厚的化学气味，走完了部分产线，可能是刚刚开工的缘故，部分产线员工稀少，有的已经满员。虽然只是一次以围观者和学习者的心态走过产线，还是会有些个人感触，以下仅代表个人观点，不喜请忘。 真是忙的忙死，闲的闲死 科学技术是第一生产力（认真脸） 化工产品对身体危害真的很大 庆幸自己非产线人员（非歧视） 大致感受也不会太多，仅此而已 作者 Felix2018 年 02月 24日]]></content>
      <categories>
        <category>Work</category>
      </categories>
      <tags>
        <tag>Work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好，Blog]]></title>
    <url>%2F2018%2F02%2F23%2FHello%2F</url>
    <content type="text"><![CDATA[将碎片化时间利用起来 新的起点 一个崭新的世界，开始在闲暇之余记录自己每天的生活，以下是自己的2018个人目标： 充实自己，完成公司内自己应尽的职责 发布日记，杂文，所见所想 撰写发布技术文稿（代码支持） 多接触了解新的知识 无限折腾 趁着刚刚毕业时间充足，争取把自己以往所有想过但未实现的都一一实现，每一天都是新的开始 关于技术栈希望自己能在技术方面越走越远吧！JAVA，PHP，PYTHON，JavaScript 以下是目前博客搭建计划表 MarkDown深入研究 GitHub实时同步 添加评论功能 个人域名备案 技术翻新Vuejs 再一次感谢您花费时间阅读这份欢迎稿 作者 Felix2018 年 02月 23日]]></content>
      <categories>
        <category>Whisper</category>
      </categories>
      <tags>
        <tag>Whisper</tag>
      </tags>
  </entry>
</search>
